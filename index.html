<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Flappy Coin</title>
    <style>
        /* Красивый фон, центрирование canvas */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #87ceeb 0%, #b2f2bb 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
            background: #a3d9a5;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script>
        (() => {
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');

            // Сделать canvas размером во весь экран (учитываем dpr)
            function resize() {
                const dpr = window.devicePixelRatio || 1;
                canvas.width = window.innerWidth * dpr;
                canvas.height = window.innerHeight * dpr;
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(dpr, dpr);
            }
            resize();
            window.addEventListener('resize', resize);

            // Настройки игры
            const gravity = 1200; // пикселей в секунду^2 (ускорение падения)
            const jumpVelocity = -450; // скорость прыжка (отрицательная — вверх)
            const pipeSpeed = 280; // пикселей в секунду (скорость труб)
            const pipeGap = 180; // промежуток между трубами по вертикали
            const pipeWidth = 60;
            const pipeInterval = 2000; // миллисекунд между трубами

            // Монетка (птица) параметры
            const coinRadius = 20;
            const coinX = 100; // горизонтальная позиция монеты — не меняется

            // Состояние игры
            let coinY = canvas.height / (window.devicePixelRatio || 1) / 2;
            let coinVelocity = 0;
            let pipes = [];
            let lastPipeTime = 0;
            let lastFrameTime = 0;
            let gameOver = false;
            let score = 0;

            // Управление (клик, пробел, тач)
            function jump() {
                if (gameOver) {
                    resetGame();
                    return;
                }
                coinVelocity = jumpVelocity;
            }
            window.addEventListener('keydown', e => { if (e.code === 'Space') jump(); });
            window.addEventListener('mousedown', jump);
            window.addEventListener('touchstart', e => { e.preventDefault(); jump(); }, { passive: false });

            // Сброс игры
            function resetGame() {
                coinY = canvas.height / (window.devicePixelRatio || 1) / 2;
                coinVelocity = 0;
                pipes = [];
                lastPipeTime = 0;
                score = 0;
                gameOver = false;
            }

            // Создать новую трубу (верх и низ)
            function createPipe() {
                const canvasH = canvas.height / (window.devicePixelRatio || 1);
                // Высота верхней трубы: от 50px до canvasH - pipeGap - 50
                const topHeight = 50 + Math.random() * (canvasH - pipeGap - 100);
                pipes.push({ x: canvas.width / (window.devicePixelRatio || 1), topHeight });
            }

            // Проверка пересечения круга (монеты) с прямоугольником (трубой)
            function circleRectCollision(cx, cy, radius, rx, ry, rw, rh) {
                // Найти ближайшую точку прямоугольника к центру круга
                const nearestX = Math.max(rx, Math.min(cx, rx + rw));
                const nearestY = Math.max(ry, Math.min(cy, ry + rh));
                const dx = cx - nearestX;
                const dy = cy - nearestY;
                return (dx * dx + dy * dy) < radius * radius;
            }

            // Отрисовка монетки (желтый круг с $)
            function drawCoin(x, y) {
                ctx.fillStyle = '#f7d84b';
                ctx.beginPath();
                ctx.shadowColor = 'rgba(255, 255, 0, 0.6)';
                ctx.shadowBlur = 15;
                ctx.arc(x, y, coinRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.fillStyle = '#b38600';
                ctx.font = '28px Arial, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('$', x, y + 1);
            }

            // Отрисовка трубы зеленого оттенка
            function drawPipe(x, topHeight, canvasH) {
                const greenTop = '#2e7d32';
                const greenBottom = '#4caf50';

                // Верхняя труба
                ctx.fillStyle = greenTop;
                ctx.fillRect(x, 0, pipeWidth, topHeight);

                // Нижняя труба
                ctx.fillStyle = greenBottom;
                ctx.fillRect(x, topHeight + pipeGap, pipeWidth, canvasH - (topHeight + pipeGap));
            }

            // Отрисовка счета
            function drawScore() {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 36px Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 5;
                ctx.fillText(`Score: ${score}`, canvas.width / (window.devicePixelRatio || 1) / 2, 50);
                ctx.shadowBlur = 0;
            }

            // Основной игровой цикл
            function gameLoop(timestamp = 0) {
                if (!lastFrameTime) lastFrameTime = timestamp;
                const deltaTime = (timestamp - lastFrameTime) / 1000; // в секундах
                lastFrameTime = timestamp;

                if (gameOver) {
                    // Отрисовать "Game Over" и ждать рестарт
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawScore();
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.font = 'bold 72px Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Game Over', canvas.width / (window.devicePixelRatio || 1) / 2, canvas.height / (window.devicePixelRatio || 1) / 2);
                    ctx.font = '24px Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
                    ctx.fillText('Click or press Space to restart', canvas.width / (window.devicePixelRatio || 1) / 2, canvas.height / (window.devicePixelRatio || 1) / 2 + 50);
                    return;
                }

                // Обновление позиции монеты
                coinVelocity += gravity * deltaTime;
                coinY += coinVelocity * deltaTime;

                const canvasH = canvas.height / (window.devicePixelRatio || 1);

                // Создание труб по времени
                if (timestamp - lastPipeTime > pipeInterval) {
                    createPipe();
                    lastPipeTime = timestamp;
                }

                // Обновление положения труб и проверка столкновений
                pipes.forEach(pipe => {
                    pipe.x -= pipeSpeed * deltaTime;
                });

                // Удаление труб, вышедших за экран слева
                if (pipes.length && pipes[0].x + pipeWidth < 0) {
                    pipes.shift();
                    score++;
                }

                // Проверка столкновений с трубами
                for (let pipe of pipes) {
                    if (
                        circleRectCollision(coinX, coinY, coinRadius, pipe.x, 0, pipeWidth, pipe.topHeight) ||
                        circleRectCollision(coinX, coinY, coinRadius, pipe.x, pipe.topHeight + pipeGap, pipeWidth, canvasH - (pipe.topHeight + pipeGap))
                    ) {
                        gameOver = true;
                    }
                }

                // Проверка столкновения с землей и потолком
                if (coinY + coinRadius > canvasH || coinY - coinRadius < 0) {
                    gameOver = true;
                }

                // Отрисовка
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Трубы
                pipes.forEach(pipe => drawPipe(pipe.x, pipe.topHeight, canvasH));

                // Монетка
                drawCoin(coinX, coinY);

                // Счет
                drawScore();

                requestAnimationFrame(gameLoop);
            }

            // Запуск
            resetGame();
            requestAnimationFrame(gameLoop);
        })();
    </script>
</body>
</html>