<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Flappy Coin</title>
    <style>
        /* Фон и центровка */
        body, html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #87ceeb 0%, #b2f2bb 100%);
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            user-select: none; /* запрет выделения текста */
            overflow: hidden;
        }

        canvas {
            background: linear-gradient(to bottom, #a3d9a5, #76b56a);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script>
        (() => {
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');

            function resize() {
                const dpr = window.devicePixelRatio || 1;
                canvas.width = window.innerWidth * dpr;
                canvas.height = window.innerHeight * dpr;
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(dpr, dpr);
            }
            resize();
            window.addEventListener('resize', resize);

            // Настройки и лимиты
            const baseGravity = 800;
            const baseJumpVelocity = -300;
            const basePipeSpeed = 185;
            const pipeGap = 180;
            const pipeWidth = 60;
            const pipeInterval = 2000;

            const coinRadius = 20;
            const coinX = 100;

            // Максимальные значения для прогрессии
            const maxPipeSpeed = 450;
            const maxGravity = 1400;

            // Скорость изменения сложностей
            const difficultyIncreaseRate = 0.03;

            let coinY, coinVelocity, pipes, lastPipeTime, lastFrameTime, gameOver, score;
            let pipeSpeed, gravity, jumpVelocity;
            let animationId = null;

            function resetGame() {
                coinY = canvas.height / (window.devicePixelRatio || 1) / 2;
                coinVelocity = 0;
                pipes = [];
                lastPipeTime = 0;
                lastFrameTime = 0;
                gameOver = false;
                score = 0;

                pipeSpeed = basePipeSpeed;
                gravity = baseGravity;
                jumpVelocity = baseJumpVelocity;

                if (!animationId) {
                    animationId = requestAnimationFrame(gameLoop);
                }
            }

            // Создаём трубы
            function createPipe() {
                const canvasH = canvas.height / (window.devicePixelRatio || 1);
                const topHeight = 50 + Math.random() * (canvasH - pipeGap - 100);
                pipes.push({ x: canvas.width / (window.devicePixelRatio || 1), topHeight });
            }

            // Проверка коллизии круга и прямоугольника
            function circleRectCollision(cx, cy, radius, rx, ry, rw, rh) {
                const nearestX = Math.max(rx, Math.min(cx, rx + rw));
                const nearestY = Math.max(ry, Math.min(cy, ry + rh));
                const dx = cx - nearestX;
                const dy = cy - nearestY;
                return (dx * dx + dy * dy) < (radius * radius);
            }

            // Рисуем монету с градиентом и тенями
            function drawCoin(x, y) {
                const grad = ctx.createRadialGradient(x, y, coinRadius * 0.3, x, y, coinRadius);
                grad.addColorStop(0, '#fff46e');
                grad.addColorStop(1, '#f7d84b');

                ctx.fillStyle = grad;
                ctx.shadowColor = 'rgba(255, 255, 100, 0.8)';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(x, y, coinRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.fillStyle = '#b38600';
                ctx.font = '28px Arial, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('$', x, y + 1);
            }

            // Рисуем трубы с легким градиентом
            function drawPipe(x, topHeight, canvasH) {
                // Градиенты для верхней и нижней трубы
                const gradTop = ctx.createLinearGradient(x, 0, x + pipeWidth, topHeight);
                gradTop.addColorStop(0, '#1b5e20');
                gradTop.addColorStop(1, '#388e3c');

                const gradBottom = ctx.createLinearGradient(x, topHeight + pipeGap, x + pipeWidth, canvasH);
                gradBottom.addColorStop(0, '#388e3c');
                gradBottom.addColorStop(1, '#66bb6a');

                ctx.fillStyle = gradTop;
                ctx.fillRect(x, 0, pipeWidth, topHeight);

                ctx.fillStyle = gradBottom;
                ctx.fillRect(x, topHeight + pipeGap, pipeWidth, canvasH - (topHeight + pipeGap));
            }

            // Рисуем счёт с тенью
            function drawScore() {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 36px Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 6;
                ctx.fillText(`Score: ${score}`, canvas.width / (window.devicePixelRatio || 1) / 2, 50);
                ctx.shadowBlur = 0;
            }

            // Основной цикл игры
            function gameLoop(timestamp = 0) {
                if (!lastFrameTime) lastFrameTime = timestamp;
                const deltaTime = (timestamp - lastFrameTime) / 1000;
                lastFrameTime = timestamp;

                if (gameOver) {
                    // Отрисовка экрана Game Over
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawScore();
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.font = 'bold 72px Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Game Over', canvas.width / (window.devicePixelRatio || 1) / 2, canvas.height / (window.devicePixelRatio || 1) / 2);
                    ctx.font = '24px Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
                    ctx.fillText('Click or press Space to restart', canvas.width / (window.devicePixelRatio || 1) / 2, canvas.height / (window.devicePixelRatio || 1) / 2 + 50);

                    animationId = null; // останавливаем анимацию, но она будет запущена при рестарте
                    return;
                }

                // Увеличиваем скорость и гравитацию, но с лимитом
                pipeSpeed = Math.min(maxPipeSpeed, pipeSpeed + difficultyIncreaseRate * deltaTime * 20);
                gravity = Math.min(maxGravity, gravity + difficultyIncreaseRate * deltaTime * 40);

                coinVelocity += gravity * deltaTime;
                coinY += coinVelocity * deltaTime;

                const canvasH = canvas.height / (window.devicePixelRatio || 1);

                if (timestamp - lastPipeTime > pipeInterval) {
                    createPipe();
                    lastPipeTime = timestamp;
                }

                pipes.forEach(pipe => {
                    pipe.x -= pipeSpeed * deltaTime;
                });

                if (pipes.length && pipes[0].x + pipeWidth < 0) {
                    pipes.shift();
                    score++;
                }

                for (let pipe of pipes) {
                    if (
                        circleRectCollision(coinX, coinY, coinRadius, pipe.x, 0, pipeWidth, pipe.topHeight) ||
                        circleRectCollision(coinX, coinY, coinRadius, pipe.x, pipe.topHeight + pipeGap, pipeWidth, canvasH - (pipe.topHeight + pipeGap))
                    ) {
                        gameOver = true;
                    }
                }

                if (coinY + coinRadius > canvasH || coinY - coinRadius < 0) {
                    gameOver = true;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                pipes.forEach(pipe => drawPipe(pipe.x, pipe.topHeight, canvasH));
                drawCoin(coinX, coinY);
                drawScore();

                animationId = requestAnimationFrame(gameLoop);
            }

            // Обработка прыжка и рестарта
            function jump() {
                if (gameOver) {
                    resetGame();
                }
                coinVelocity = jumpVelocity;
            }

            window.addEventListener('keydown', e => {
                if (e.code === 'Space') jump();
            });
            window.addEventListener('mousedown', jump);
            window.addEventListener('touchstart', e => {
                e.preventDefault();
                jump();
            }, { passive: false });

            resetGame();
        })();
    </script>
</body>
</html>